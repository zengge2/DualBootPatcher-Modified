// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RESPONSE_MBTOOL_DAEMON_V3_H_
#define FLATBUFFERS_GENERATED_RESPONSE_MBTOOL_DAEMON_V3_H_

#include "flatbuffers/flatbuffers.h"

#include "crypto_decrypt_generated.h"
#include "crypto_get_pw_type_generated.h"
#include "file_chmod_generated.h"
#include "file_close_generated.h"
#include "file_open_generated.h"
#include "file_read_generated.h"
#include "file_seek_generated.h"
#include "file_selinux_get_label_generated.h"
#include "file_selinux_set_label_generated.h"
#include "file_stat_generated.h"
#include "file_write_generated.h"
#include "mb_get_booted_rom_id_generated.h"
#include "mb_get_installed_roms_generated.h"
#include "mb_get_packages_count_generated.h"
#include "mb_get_version_generated.h"
#include "mb_set_kernel_generated.h"
#include "mb_switch_rom_generated.h"
#include "mb_wipe_rom_generated.h"
#include "path_chmod_generated.h"
#include "path_copy_generated.h"
#include "path_delete_generated.h"
#include "path_get_directory_size_generated.h"
#include "path_mkdir_generated.h"
#include "path_readlink_generated.h"
#include "path_selinux_get_label_generated.h"
#include "path_selinux_set_label_generated.h"
#include "reboot_generated.h"
#include "shutdown_generated.h"
#include "signed_exec_generated.h"

namespace mbtool {
namespace daemon {
namespace v3 {

struct Invalid;

struct Unsupported;

struct Response;

enum ResponseType {
  ResponseType_NONE = 0,
  ResponseType_Invalid = 1,
  ResponseType_Unsupported = 2,
  ResponseType_FileChmodResponse = 3,
  ResponseType_FileCloseResponse = 4,
  ResponseType_FileOpenResponse = 5,
  ResponseType_FileReadResponse = 6,
  ResponseType_FileSeekResponse = 7,
  ResponseType_FileStatResponse = 8,
  ResponseType_FileWriteResponse = 9,
  ResponseType_FileSELinuxGetLabelResponse = 10,
  ResponseType_FileSELinuxSetLabelResponse = 11,
  ResponseType_PathChmodResponse = 12,
  ResponseType_PathCopyResponse = 13,
  ResponseType_PathSELinuxGetLabelResponse = 14,
  ResponseType_PathSELinuxSetLabelResponse = 15,
  ResponseType_PathGetDirectorySizeResponse = 16,
  ResponseType_MbGetVersionResponse = 17,
  ResponseType_MbGetInstalledRomsResponse = 18,
  ResponseType_MbGetBootedRomIdResponse = 19,
  ResponseType_MbSwitchRomResponse = 20,
  ResponseType_MbSetKernelResponse = 21,
  ResponseType_MbWipeRomResponse = 22,
  ResponseType_MbGetPackagesCountResponse = 23,
  ResponseType_RebootResponse = 24,
  ResponseType_SignedExecOutputResponse = 25,
  ResponseType_SignedExecResponse = 26,
  ResponseType_ShutdownResponse = 27,
  ResponseType_PathDeleteResponse = 28,
  ResponseType_PathMkdirResponse = 29,
  ResponseType_CryptoDecryptResponse = 30,
  ResponseType_CryptoGetPwTypeResponse = 31,
  ResponseType_PathReadlinkResponse = 32,
  ResponseType_MIN = ResponseType_NONE,
  ResponseType_MAX = ResponseType_PathReadlinkResponse
};

inline const char **EnumNamesResponseType() {
  static const char *names[] = {
    "NONE",
    "Invalid",
    "Unsupported",
    "FileChmodResponse",
    "FileCloseResponse",
    "FileOpenResponse",
    "FileReadResponse",
    "FileSeekResponse",
    "FileStatResponse",
    "FileWriteResponse",
    "FileSELinuxGetLabelResponse",
    "FileSELinuxSetLabelResponse",
    "PathChmodResponse",
    "PathCopyResponse",
    "PathSELinuxGetLabelResponse",
    "PathSELinuxSetLabelResponse",
    "PathGetDirectorySizeResponse",
    "MbGetVersionResponse",
    "MbGetInstalledRomsResponse",
    "MbGetBootedRomIdResponse",
    "MbSwitchRomResponse",
    "MbSetKernelResponse",
    "MbWipeRomResponse",
    "MbGetPackagesCountResponse",
    "RebootResponse",
    "SignedExecOutputResponse",
    "SignedExecResponse",
    "ShutdownResponse",
    "PathDeleteResponse",
    "PathMkdirResponse",
    "CryptoDecryptResponse",
    "CryptoGetPwTypeResponse",
    "PathReadlinkResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNameResponseType(ResponseType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesResponseType()[index];
}

template<typename T> struct ResponseTypeTraits {
  static const ResponseType enum_value = ResponseType_NONE;
};

template<> struct ResponseTypeTraits<Invalid> {
  static const ResponseType enum_value = ResponseType_Invalid;
};

template<> struct ResponseTypeTraits<Unsupported> {
  static const ResponseType enum_value = ResponseType_Unsupported;
};

template<> struct ResponseTypeTraits<mbtool::daemon::v3::FileChmodResponse> {
  static const ResponseType enum_value = ResponseType_FileChmodResponse;
};

template<> struct ResponseTypeTraits<mbtool::daemon::v3::FileCloseResponse> {
  static const ResponseType enum_value = ResponseType_FileCloseResponse;
};

template<> struct ResponseTypeTraits<mbtool::daemon::v3::FileOpenResponse> {
  static const ResponseType enum_value = ResponseType_FileOpenResponse;
};

template<> struct ResponseTypeTraits<mbtool::daemon::v3::FileReadResponse> {
  static const ResponseType enum_value = ResponseType_FileReadResponse;
};

template<> struct ResponseTypeTraits<mbtool::daemon::v3::FileSeekResponse> {
  static const ResponseType enum_value = ResponseType_FileSeekResponse;
};

template<> struct ResponseTypeTraits<mbtool::daemon::v3::FileStatResponse> {
  static const ResponseType enum_value = ResponseType_FileStatResponse;
};

template<> struct ResponseTypeTraits<mbtool::daemon::v3::FileWriteResponse> {
  static const ResponseType enum_value = ResponseType_FileWriteResponse;
};

template<> struct ResponseTypeTraits<mbtool::daemon::v3::FileSELinuxGetLabelResponse> {
  static const ResponseType enum_value = ResponseType_FileSELinuxGetLabelResponse;
};

template<> struct ResponseTypeTraits<mbtool::daemon::v3::FileSELinuxSetLabelResponse> {
  static const ResponseType enum_value = ResponseType_FileSELinuxSetLabelResponse;
};

template<> struct ResponseTypeTraits<mbtool::daemon::v3::PathChmodResponse> {
  static const ResponseType enum_value = ResponseType_PathChmodResponse;
};

template<> struct ResponseTypeTraits<mbtool::daemon::v3::PathCopyResponse> {
  static const ResponseType enum_value = ResponseType_PathCopyResponse;
};

template<> struct ResponseTypeTraits<mbtool::daemon::v3::PathSELinuxGetLabelResponse> {
  static const ResponseType enum_value = ResponseType_PathSELinuxGetLabelResponse;
};

template<> struct ResponseTypeTraits<mbtool::daemon::v3::PathSELinuxSetLabelResponse> {
  static const ResponseType enum_value = ResponseType_PathSELinuxSetLabelResponse;
};

template<> struct ResponseTypeTraits<mbtool::daemon::v3::PathGetDirectorySizeResponse> {
  static const ResponseType enum_value = ResponseType_PathGetDirectorySizeResponse;
};

template<> struct ResponseTypeTraits<mbtool::daemon::v3::MbGetVersionResponse> {
  static const ResponseType enum_value = ResponseType_MbGetVersionResponse;
};

template<> struct ResponseTypeTraits<mbtool::daemon::v3::MbGetInstalledRomsResponse> {
  static const ResponseType enum_value = ResponseType_MbGetInstalledRomsResponse;
};

template<> struct ResponseTypeTraits<mbtool::daemon::v3::MbGetBootedRomIdResponse> {
  static const ResponseType enum_value = ResponseType_MbGetBootedRomIdResponse;
};

template<> struct ResponseTypeTraits<mbtool::daemon::v3::MbSwitchRomResponse> {
  static const ResponseType enum_value = ResponseType_MbSwitchRomResponse;
};

template<> struct ResponseTypeTraits<mbtool::daemon::v3::MbSetKernelResponse> {
  static const ResponseType enum_value = ResponseType_MbSetKernelResponse;
};

template<> struct ResponseTypeTraits<mbtool::daemon::v3::MbWipeRomResponse> {
  static const ResponseType enum_value = ResponseType_MbWipeRomResponse;
};

template<> struct ResponseTypeTraits<mbtool::daemon::v3::MbGetPackagesCountResponse> {
  static const ResponseType enum_value = ResponseType_MbGetPackagesCountResponse;
};

template<> struct ResponseTypeTraits<mbtool::daemon::v3::RebootResponse> {
  static const ResponseType enum_value = ResponseType_RebootResponse;
};

template<> struct ResponseTypeTraits<mbtool::daemon::v3::SignedExecOutputResponse> {
  static const ResponseType enum_value = ResponseType_SignedExecOutputResponse;
};

template<> struct ResponseTypeTraits<mbtool::daemon::v3::SignedExecResponse> {
  static const ResponseType enum_value = ResponseType_SignedExecResponse;
};

template<> struct ResponseTypeTraits<mbtool::daemon::v3::ShutdownResponse> {
  static const ResponseType enum_value = ResponseType_ShutdownResponse;
};

template<> struct ResponseTypeTraits<mbtool::daemon::v3::PathDeleteResponse> {
  static const ResponseType enum_value = ResponseType_PathDeleteResponse;
};

template<> struct ResponseTypeTraits<mbtool::daemon::v3::PathMkdirResponse> {
  static const ResponseType enum_value = ResponseType_PathMkdirResponse;
};

template<> struct ResponseTypeTraits<mbtool::daemon::v3::CryptoDecryptResponse> {
  static const ResponseType enum_value = ResponseType_CryptoDecryptResponse;
};

template<> struct ResponseTypeTraits<mbtool::daemon::v3::CryptoGetPwTypeResponse> {
  static const ResponseType enum_value = ResponseType_CryptoGetPwTypeResponse;
};

template<> struct ResponseTypeTraits<mbtool::daemon::v3::PathReadlinkResponse> {
  static const ResponseType enum_value = ResponseType_PathReadlinkResponse;
};

bool VerifyResponseType(flatbuffers::Verifier &verifier, const void *obj, ResponseType type);
bool VerifyResponseTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Invalid FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct InvalidBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  InvalidBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InvalidBuilder &operator=(const InvalidBuilder &);
  flatbuffers::Offset<Invalid> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<Invalid>(end);
    return o;
  }
};

inline flatbuffers::Offset<Invalid> CreateInvalid(
    flatbuffers::FlatBufferBuilder &_fbb) {
  InvalidBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Unsupported FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct UnsupportedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  UnsupportedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnsupportedBuilder &operator=(const UnsupportedBuilder &);
  flatbuffers::Offset<Unsupported> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<Unsupported>(end);
    return o;
  }
};

inline flatbuffers::Offset<Unsupported> CreateUnsupported(
    flatbuffers::FlatBufferBuilder &_fbb) {
  UnsupportedBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Response FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESPONSE_TYPE = 4,
    VT_RESPONSE = 6
  };
  ResponseType response_type() const {
    return static_cast<ResponseType>(GetField<uint8_t>(VT_RESPONSE_TYPE, 0));
  }
  const void *response() const {
    return GetPointer<const void *>(VT_RESPONSE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RESPONSE_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_RESPONSE) &&
           VerifyResponseType(verifier, response(), response_type()) &&
           verifier.EndTable();
  }
};

struct ResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_response_type(ResponseType response_type) {
    fbb_.AddElement<uint8_t>(Response::VT_RESPONSE_TYPE, static_cast<uint8_t>(response_type), 0);
  }
  void add_response(flatbuffers::Offset<void> response) {
    fbb_.AddOffset(Response::VT_RESPONSE, response);
  }
  ResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResponseBuilder &operator=(const ResponseBuilder &);
  flatbuffers::Offset<Response> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Response>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response> CreateResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ResponseType response_type = ResponseType_NONE,
    flatbuffers::Offset<void> response = 0) {
  ResponseBuilder builder_(_fbb);
  builder_.add_response(response);
  builder_.add_response_type(response_type);
  return builder_.Finish();
}

inline bool VerifyResponseType(flatbuffers::Verifier &verifier, const void *obj, ResponseType type) {
  switch (type) {
    case ResponseType_NONE: {
      return true;
    }
    case ResponseType_Invalid: {
      auto ptr = reinterpret_cast<const Invalid *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_Unsupported: {
      auto ptr = reinterpret_cast<const Unsupported *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_FileChmodResponse: {
      auto ptr = reinterpret_cast<const mbtool::daemon::v3::FileChmodResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_FileCloseResponse: {
      auto ptr = reinterpret_cast<const mbtool::daemon::v3::FileCloseResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_FileOpenResponse: {
      auto ptr = reinterpret_cast<const mbtool::daemon::v3::FileOpenResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_FileReadResponse: {
      auto ptr = reinterpret_cast<const mbtool::daemon::v3::FileReadResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_FileSeekResponse: {
      auto ptr = reinterpret_cast<const mbtool::daemon::v3::FileSeekResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_FileStatResponse: {
      auto ptr = reinterpret_cast<const mbtool::daemon::v3::FileStatResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_FileWriteResponse: {
      auto ptr = reinterpret_cast<const mbtool::daemon::v3::FileWriteResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_FileSELinuxGetLabelResponse: {
      auto ptr = reinterpret_cast<const mbtool::daemon::v3::FileSELinuxGetLabelResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_FileSELinuxSetLabelResponse: {
      auto ptr = reinterpret_cast<const mbtool::daemon::v3::FileSELinuxSetLabelResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_PathChmodResponse: {
      auto ptr = reinterpret_cast<const mbtool::daemon::v3::PathChmodResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_PathCopyResponse: {
      auto ptr = reinterpret_cast<const mbtool::daemon::v3::PathCopyResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_PathSELinuxGetLabelResponse: {
      auto ptr = reinterpret_cast<const mbtool::daemon::v3::PathSELinuxGetLabelResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_PathSELinuxSetLabelResponse: {
      auto ptr = reinterpret_cast<const mbtool::daemon::v3::PathSELinuxSetLabelResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_PathGetDirectorySizeResponse: {
      auto ptr = reinterpret_cast<const mbtool::daemon::v3::PathGetDirectorySizeResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_MbGetVersionResponse: {
      auto ptr = reinterpret_cast<const mbtool::daemon::v3::MbGetVersionResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_MbGetInstalledRomsResponse: {
      auto ptr = reinterpret_cast<const mbtool::daemon::v3::MbGetInstalledRomsResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_MbGetBootedRomIdResponse: {
      auto ptr = reinterpret_cast<const mbtool::daemon::v3::MbGetBootedRomIdResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_MbSwitchRomResponse: {
      auto ptr = reinterpret_cast<const mbtool::daemon::v3::MbSwitchRomResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_MbSetKernelResponse: {
      auto ptr = reinterpret_cast<const mbtool::daemon::v3::MbSetKernelResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_MbWipeRomResponse: {
      auto ptr = reinterpret_cast<const mbtool::daemon::v3::MbWipeRomResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_MbGetPackagesCountResponse: {
      auto ptr = reinterpret_cast<const mbtool::daemon::v3::MbGetPackagesCountResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_RebootResponse: {
      auto ptr = reinterpret_cast<const mbtool::daemon::v3::RebootResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_SignedExecOutputResponse: {
      auto ptr = reinterpret_cast<const mbtool::daemon::v3::SignedExecOutputResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_SignedExecResponse: {
      auto ptr = reinterpret_cast<const mbtool::daemon::v3::SignedExecResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_ShutdownResponse: {
      auto ptr = reinterpret_cast<const mbtool::daemon::v3::ShutdownResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_PathDeleteResponse: {
      auto ptr = reinterpret_cast<const mbtool::daemon::v3::PathDeleteResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_PathMkdirResponse: {
      auto ptr = reinterpret_cast<const mbtool::daemon::v3::PathMkdirResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_CryptoDecryptResponse: {
      auto ptr = reinterpret_cast<const mbtool::daemon::v3::CryptoDecryptResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_CryptoGetPwTypeResponse: {
      auto ptr = reinterpret_cast<const mbtool::daemon::v3::CryptoGetPwTypeResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_PathReadlinkResponse: {
      auto ptr = reinterpret_cast<const mbtool::daemon::v3::PathReadlinkResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyResponseTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyResponseType(
        verifier,  values->Get(i), types->GetEnum<ResponseType>(i))) {
      return false;
    }
  }
  return true;
}

inline const mbtool::daemon::v3::Response *GetResponse(const void *buf) {
  return flatbuffers::GetRoot<mbtool::daemon::v3::Response>(buf);
}

inline bool VerifyResponseBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<mbtool::daemon::v3::Response>(nullptr);
}

inline void FinishResponseBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<mbtool::daemon::v3::Response> root) {
  fbb.Finish(root);
}

}  // namespace v3
}  // namespace daemon
}  // namespace mbtool

#endif  // FLATBUFFERS_GENERATED_RESPONSE_MBTOOL_DAEMON_V3_H_
